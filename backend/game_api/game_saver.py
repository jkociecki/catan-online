# backend/game_api/game_saver.py - NAPRAWIONA WERSJA - zapisuje wszystkich graczy
from django.contrib.auth import get_user_model
from django.db.models import Q  # ‚úÖ DODANY IMPORT!
from game_api.models import Game, GamePlayer, PlayerResource
import json
from datetime import datetime
import logging
from django.db import transaction

User = get_user_model()
logger = logging.getLogger(__name__)

class GameSaver:
    """Klasa do zapisywania zako≈Ñczonych gier do bazy danych"""
    
    @staticmethod
    def save_completed_game(game_state, start_time=None):
        """
        Zapisz zako≈ÑczonƒÖ grƒô do bazy danych - POPRAWIONA WERSJA
        Zapisuje WSZYSTKICH graczy, nawet je≈õli niekt√≥rzy majƒÖ problemy
        """
        try:
            logger.info(f"üéÆ Saving completed game to database")
            
            # Sprawd≈∫ czy gra rzeczywi≈õcie siƒô sko≈Ñczy≈Ça
            if not game_state.is_game_over():
                logger.warning("‚ùå Game is not finished yet, skipping save")
                return None
            
            # ‚úÖ POBIERZ ROZK≈ÅAD KOSTEK Z GAME_STATE
            dice_distribution = getattr(game_state, 'dice_distribution', {})
            if not dice_distribution:
                logger.info("üìä No dice distribution found in game_state, using empty dict")
                dice_distribution = {}
            else:
                logger.info(f"üé≤ Found dice distribution: {dice_distribution}")
            
            # ‚úÖ TWORZYMY GRƒò Z ROZK≈ÅADEM KOSTEK
            game = Game.objects.create(
                start_time=start_time or datetime.now(),
                end_time=datetime.now(),
                dice_distribution=dice_distribution,  # ‚úÖ PRAWDZIWY ROZK≈ÅAD!
                turns=getattr(game_state, 'current_turn', 0)
            )
            
            logger.info(f"‚úÖ Created Game object with ID: {game.id}, dice_distribution: {dice_distribution}")
            
            saved_players = []
            failed_players = []
            
            # ‚úÖ ZAPISUJEMY KA≈ªDEGO GRACZA OSOBNO - z lepszƒÖ logikƒÖ
            for player_id, player in game_state.players.items():
                try:
                    logger.info(f"üéØ Processing player {player_id[:8]} - display_name: '{getattr(player, 'display_name', 'N/A')}'")
                    
                    # Spr√≥buj zapisaƒá tego gracza w osobnej transakcji
                    with transaction.atomic():
                        user = GameSaver._get_real_user_for_player(player_id, player)
                        
                        if not user:
                            logger.error(f"‚ùå Could not find/create user for player {player_id[:8]}")
                            failed_players.append({
                                'player_id': player_id[:8],
                                'display_name': getattr(player, 'display_name', 'N/A'),
                                'reason': 'User not found/created'
                            })
                            continue
                        
                        # ‚úÖ SPRAWD≈π CZY GRACZ JU≈ª ISTNIEJE W TEJ GRZE
                        existing = GamePlayer.objects.filter(game=game, user=user).first()
                        if existing:
                            logger.warning(f"‚ö†Ô∏è Player {user.username} already exists in game {game.id}, skipping")
                            continue
                        
                        # Utw√≥rz GamePlayer
                        game_player = GamePlayer.objects.create(
                            game=game,
                            user=user,
                            victory_points=getattr(player, 'victory_points', 0),
                            roads_built=15 - getattr(player, 'roads_left', 15),
                            settlements_built=5 - getattr(player, 'settlements_left', 5),
                            cities_built=4 - getattr(player, 'cities_left', 4),
                            longest_road=getattr(player, 'longest_road', False),
                            largest_army=getattr(player, 'largest_army', False)
                        )
                        
                        logger.info(f"‚úÖ Created GamePlayer for {player.display_name} (User: {user.username}, ID: {user.id})")
                        
                        # Zapisz zasoby gracza
                        GameSaver._save_player_resources(game_player, getattr(player, 'resources', None))
                        
                        saved_players.append({
                            'player_id': player_id[:8],
                            'username': user.username,
                            'display_name': getattr(player, 'display_name', 'N/A'),
                            'victory_points': getattr(player, 'victory_points', 0)
                        })
                        
                except Exception as e:
                    logger.error(f"‚ùå Error saving player {player_id[:8]}: {e}")
                    failed_players.append({
                        'player_id': player_id[:8],
                        'display_name': getattr(player, 'display_name', 'N/A'),
                        'reason': str(e)
                    })
                    # ‚úÖ NIE PRZERYWAMY - idziemy dalej do nastƒôpnego gracza
                    continue
            
            # ‚úÖ SZCZEG√ì≈ÅOWE LOGOWANIE WYNIK√ìW
            logger.info(f"üéâ Game {game.id} saved!")
            logger.info(f"üìä Total players in game_state: {len(game_state.players)}")
            logger.info(f"‚úÖ Successfully saved: {len(saved_players)} players")
            logger.info(f"‚ùå Failed to save: {len(failed_players)} players")
            
            if saved_players:
                logger.info("‚úÖ SAVED PLAYERS:")
                for sp in saved_players:
                    logger.info(f"   - {sp['username']} ({sp['display_name']}) - {sp['victory_points']} pts")
            
            if failed_players:
                logger.warning("‚ùå FAILED PLAYERS:")
                for fp in failed_players:
                    logger.warning(f"   - {fp['player_id']} ({fp['display_name']}) - {fp['reason']}")
            
            # ‚úÖ ZWRACAMY GRƒò NAWET JE≈öLI NIEKT√ìRZY GRACZE SIƒò NIE ZAPISALI
            return game
            
        except Exception as e:
            logger.error(f"‚ùå Critical error saving game to database: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    @staticmethod
    def _get_real_user_for_player(player_id, player):
        """
        ‚úÖ ULEPSZONA WERSJA - Znajd≈∫ prawdziwego u≈ºytkownika dla gracza
        """
        try:
            display_name = getattr(player, 'display_name', str(player_id))
            color = getattr(player, 'color', 'blue')
            logger.info(f"üîç Looking for user - player_id: {player_id[:8]}, display_name: '{display_name}', color: '{color}'")
            
            # ‚úÖ METODA 1: Szukaj zalogowanych u≈ºytkownik√≥w po display_name
            try:
                user = User.objects.get(display_name=display_name, is_guest=False)
                logger.info(f"‚úÖ Method 1: Found LOGGED IN user by display_name: {user.username} (ID: {user.id})")
                return user
            except User.DoesNotExist:
                logger.info("‚è≠Ô∏è Method 1 failed: No logged user with this display_name")
            except User.MultipleObjectsReturned:
                # Je≈õli jest kilku u≈ºytkownik√≥w o tej samej nazwie, we≈∫ pierwszego zalogowanego
                user = User.objects.filter(display_name=display_name, is_guest=False).first()
                if user:
                    logger.info(f"‚úÖ Method 1b: Found FIRST logged user: {user.username} (ID: {user.id})")
                    return user
            
            # ‚úÖ METODA 2: Szukaj zalogowanych u≈ºytkownik√≥w po username
            try:
                user = User.objects.get(username=display_name, is_guest=False)
                logger.info(f"‚úÖ Method 2: Found LOGGED IN user by username: {user.username} (ID: {user.id})")
                return user
            except User.DoesNotExist:
                logger.info("‚è≠Ô∏è Method 2 failed: No logged user with this username")
            except User.MultipleObjectsReturned:
                user = User.objects.filter(username=display_name, is_guest=False).first()
                if user:
                    logger.info(f"‚úÖ Method 2b: Found FIRST logged user by username: {user.username} (ID: {user.id})")
                    return user
                
            # ‚úÖ METODA 3: Sprawd≈∫ czy display_name zawiera rzeczywiste imiƒô u≈ºytkownika
            try:
                if display_name and len(display_name) > 2:
                    # Szukaj po pierwszym s≈Çowie z display_name (imiƒô)
                    first_name = display_name.split()[0] if ' ' in display_name else display_name
                    
                    # Sprawd≈∫ czy istnieje u≈ºytkownik z podobnym username lub display_name
                    similar_users = User.objects.filter(
                        Q(username__icontains=first_name.lower()) | 
                        Q(display_name__icontains=first_name),
                        is_guest=False
                    ).first()
                    
                    if similar_users:
                        logger.info(f"‚úÖ Method 3: Found SIMILAR user: {similar_users.username} (ID: {similar_users.id})")
                        return similar_users
                        
                logger.info("‚è≠Ô∏è Method 3 failed: No similar users found")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Method 3 error: {e}")
            
            # ‚úÖ METODA 4: Szukaj istniejƒÖcych go≈õci o tej nazwie
            try:
                # Sprawd≈∫ r√≥≈ºne warianty username dla go≈õci
                guest_variants = [
                    f"guest_{display_name}".replace(' ', '_')[:50],
                    f"guest_{display_name.lower()}".replace(' ', '_')[:50],
                    display_name.replace(' ', '_')[:50]
                ]
                
                for variant in guest_variants:
                    try:
                        user = User.objects.get(username=variant, is_guest=True)
                        logger.info(f"‚úÖ Method 4: Found existing GUEST user: {user.username} (ID: {user.id})")
                        return user
                    except User.DoesNotExist:
                        continue
                        
                logger.info("‚è≠Ô∏è Method 4 failed: No existing guest found")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Method 4 error: {e}")
            
            # ‚úÖ METODA 5: Utw√≥rz nowego go≈õcia - TYLKO JE≈öLI NAPRAWDƒò POTRZEBA
            logger.info(f"üÜï Creating new guest user for '{display_name}'")
            
            # Generuj bezpieczny i unikalny username
            safe_name = display_name.replace(' ', '_').replace('@', '_').replace('.', '_')
            base_username = f"guest_{safe_name}"[:40]
            username = base_username
            counter = 1
            
            # Znajd≈∫ wolny username
            while User.objects.filter(username=username).exists():
                username = f"{base_username}_{counter}"
                counter += 1
                if counter > 100:  # Zabezpieczenie przed niesko≈ÑczonƒÖ pƒôtlƒÖ
                    username = f"guest_{int(datetime.now().timestamp())}"
                    break
            
            # Utw√≥rz nowego go≈õcia
            try:
                user = User.objects.create_user(
                    username=username,
                    email=f"{username}@guest.local",
                    is_guest=True,
                    display_name=display_name,
                    preferred_color=color
                )
                
                logger.info(f"‚úÖ Method 5: Created new guest user: {username} (ID: {user.id})")
                return user
                
            except Exception as create_error:
                logger.error(f"‚ùå Failed to create guest user: {create_error}")
                
                # ‚úÖ OSTATNIA SZANSA - znajd≈∫ dowolnego go≈õcia jako fallback
                try:
                    fallback_user = User.objects.filter(is_guest=True).first()
                    if fallback_user:
                        logger.warning(f"üîÑ Method 6: Using fallback guest user: {fallback_user.username}")
                        return fallback_user
                except:
                    pass
                
                return None
            
        except Exception as e:
            logger.error(f"‚ùå Critical error finding/creating user for player {player_id[:8]}: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    @staticmethod
    def _save_player_resources(game_player, resources):
        """
        Zapisz zasoby gracza - POPRAWIONA WERSJA
        """
        try:
            if not resources:
                logger.warning(f"‚ö†Ô∏è No resources found for {game_player.user.username}")
                return
                
            resource_mapping = {
                'wood': 'wood',
                'brick': 'brick', 
                'sheep': 'sheep',
                'wheat': 'wheat',
                'ore': 'ore'
            }
            
            saved_resources = []
            for resource_name, db_name in resource_mapping.items():
                try:
                    resource_amount = getattr(resources, resource_name, 0)
                    
                    if resource_amount > 0:
                        PlayerResource.objects.create(
                            game_player=game_player,
                            resource_type=db_name,
                            amount=resource_amount
                        )
                        saved_resources.append(f"{db_name}:{resource_amount}")
                except Exception as e:
                    logger.error(f"‚ùå Error saving resource {resource_name}: {e}")
            
            if saved_resources:
                logger.info(f"‚úÖ Saved resources for {game_player.user.username}: {', '.join(saved_resources)}")
            else:
                logger.info(f"üìä No resources to save for {game_player.user.username}")
            
        except Exception as e:
            logger.error(f"‚ùå Error saving resources for {game_player.user.username}: {e}")

    @staticmethod
    def get_game_statistics_for_user(user_id):
        """
        Pobierz statystyki gier dla u≈ºytkownika - BEZ ZMIAN
        """
        try:
            game_players = GamePlayer.objects.filter(user_id=user_id)
            
            if not game_players.exists():
                return {
                    'total_games': 0,
                    'wins': 0,
                    'losses': 0,
                    'win_rate': 0,
                    'average_victory_points': 0,
                    'average_roads': 0,
                    'average_settlements': 0,
                    'average_cities': 0,
                    'longest_road_awards': 0,
                    'largest_army_awards': 0,
                }
            
            total_games = game_players.count()
            wins = game_players.filter(victory_points__gte=4).count()  # ‚úÖ 4 punkty dla testowania
            
            # Oblicz ≈õrednie
            avg_points = sum(gp.victory_points for gp in game_players) / total_games
            avg_roads = sum(gp.roads_built for gp in game_players) / total_games
            avg_settlements = sum(gp.settlements_built for gp in game_players) / total_games
            avg_cities = sum(gp.cities_built for gp in game_players) / total_games
            
            return {
                'total_games': total_games,
                'wins': wins,
                'losses': total_games - wins,
                'win_rate': (wins / total_games * 100) if total_games > 0 else 0,
                'average_victory_points': round(avg_points, 2),
                'average_roads': round(avg_roads, 2),
                'average_settlements': round(avg_settlements, 2),
                'average_cities': round(avg_cities, 2),
                'longest_road_awards': game_players.filter(longest_road=True).count(),
                'largest_army_awards': game_players.filter(largest_army=True).count(),
            }
            
        except Exception as e:
            logger.error(f"‚ùå Error getting statistics for user {user_id}: {e}")
            return None